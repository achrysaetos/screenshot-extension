import { _optionalChain } from '@sentry/utils';
import { isWrapped } from '@opentelemetry/core';
import { InstrumentationBase, InstrumentationNodeModuleDefinition, InstrumentationNodeModuleFile } from '@opentelemetry/instrumentation';
import { NestInstrumentation } from '@opentelemetry/instrumentation-nestjs-core';
import { defineIntegration, SDK_VERSION, getActiveSpan, startSpanManual, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, withActiveSpan, getClient, getIsolationScope, getDefaultIsolationScope, captureException, spanToJSON } from '@sentry/core';
import { logger, addNonEnumerableProperty } from '@sentry/utils';
import { generateInstrumentOnce } from '../../otel/instrument.js';

const INTEGRATION_NAME = 'Nest';

const supportedVersions = ['>=8.0.0 <11'];

const sentryPatched = 'sentryPatched';

/**
 * Represents an injectable target class in NestJS.
 */

/**
 * Helper checking if a concrete target class is already patched.
 *
 * We already guard duplicate patching with isWrapped. However, isWrapped checks whether a file has been patched, whereas we use this check for concrete target classes.
 * This check might not be necessary, but better to play it safe.
 */
function isPatched(target) {
  if (target.sentryPatched) {
    return true;
  }

  addNonEnumerableProperty(target, sentryPatched, true);
  return false;
}

/**
 * Custom instrumentation for nestjs.
 *
 * This hooks into the @Injectable decorator, which is applied on class middleware, interceptors and guards.
 */
class SentryNestInstrumentation extends InstrumentationBase {
   static  __initStatic() {this.COMPONENT = '@nestjs/common';}
   static  __initStatic2() {this.COMMON_ATTRIBUTES = {
    component: SentryNestInstrumentation.COMPONENT,
  };}

   constructor(config = {}) {
    super('sentry-nestjs', SDK_VERSION, config);
  }

  /**
   * Initializes the instrumentation by defining the modules to be patched.
   */
   init() {
    const moduleDef = new InstrumentationNodeModuleDefinition(SentryNestInstrumentation.COMPONENT, supportedVersions);

    moduleDef.files.push(this._getInjectableFileInstrumentation(supportedVersions));
    return moduleDef;
  }

  /**
   * Wraps the @Injectable decorator.
   */
   _getInjectableFileInstrumentation(versions) {
    return new InstrumentationNodeModuleFile(
      '@nestjs/common/decorators/core/injectable.decorator.js',
      versions,
      (moduleExports) => {
        if (isWrapped(moduleExports.Injectable)) {
          this._unwrap(moduleExports, 'Injectable');
        }
        this._wrap(moduleExports, 'Injectable', this._createWrapInjectable());
        return moduleExports;
      },
      (moduleExports) => {
        this._unwrap(moduleExports, 'Injectable');
      },
    );
  }

  /**
   * Creates a wrapper function for the @Injectable decorator.
   *
   * Wraps the use method to instrument nest class middleware.
   */
   _createWrapInjectable() {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return function wrapInjectable(original) {
      return function wrappedInjectable(options) {
        return function (target) {
          // patch middleware
          if (typeof target.prototype.use === 'function') {
            // patch only once
            if (isPatched(target)) {
              return original(options)(target);
            }

            target.prototype.use = new Proxy(target.prototype.use, {
              apply: (originalUse, thisArgUse, argsUse) => {
                const [req, res, next, ...args] = argsUse;
                const prevSpan = getActiveSpan();

                startSpanManual(
                  {
                    name: target.name,
                    attributes: {
                      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'middleware.nestjs',
                      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.middleware.nestjs',
                    },
                  },
                  (span) => {
                    const nextProxy = new Proxy(next, {
                      apply: (originalNext, thisArgNext, argsNext) => {
                        span.end();

                        if (prevSpan) {
                          withActiveSpan(prevSpan, () => {
                            Reflect.apply(originalNext, thisArgNext, argsNext);
                          });
                        } else {
                          Reflect.apply(originalNext, thisArgNext, argsNext);
                        }
                      },
                    });

                    originalUse.apply(thisArgUse, [req, res, nextProxy, args]);
                  },
                );
              },
            });
          }

          return original(options)(target);
        };
      };
    };
  }
}SentryNestInstrumentation.__initStatic();SentryNestInstrumentation.__initStatic2();

const instrumentNestCore = generateInstrumentOnce('Nest-Core', () => {
  return new NestInstrumentation();
});

const instrumentNestCommon = generateInstrumentOnce('Nest-Common', () => {
  return new SentryNestInstrumentation();
});

const instrumentNest = Object.assign(
  () => {
    instrumentNestCore();
    instrumentNestCommon();
  },
  { id: INTEGRATION_NAME },
);

const _nestIntegration = (() => {
  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      instrumentNest();
    },
  };
}) ;

/**
 * Nest framework integration
 *
 * Capture tracing data for nest.
 */
const nestIntegration = defineIntegration(_nestIntegration);

/**
 * Setup an error handler for Nest.
 */
function setupNestErrorHandler(app, baseFilter) {
  // Sadly, NestInstrumentation has no requestHook, so we need to add the attributes here
  // We register this hook in this method, because if we register it in the integration `setup`,
  // it would always run even for users that are not even using Nest.js
  const client = getClient();
  if (client) {
    client.on('spanStart', span => {
      addNestSpanAttributes(span);
    });
  }

  app.useGlobalInterceptors({
    intercept(context, next) {
      if (getIsolationScope() === getDefaultIsolationScope()) {
        logger.warn('Isolation scope is still the default isolation scope, skipping setting transactionName.');
        return next.handle();
      }

      if (context.getType() === 'http') {
        const req = context.switchToHttp().getRequest();
        if (req.route) {
          getIsolationScope().setTransactionName(`${_optionalChain([req, 'access', _ => _.method, 'optionalAccess', _2 => _2.toUpperCase, 'call', _3 => _3()]) || 'GET'} ${req.route.path}`);
        }
      }

      return next.handle();
    },
  });

  const wrappedFilter = new Proxy(baseFilter, {
    get(target, prop, receiver) {
      if (prop === 'catch') {
        const originalCatch = Reflect.get(target, prop, receiver);

        return (exception, host) => {
          const status_code = (exception ).status;

          // don't report expected errors
          if (status_code !== undefined && status_code >= 400 && status_code < 500) {
            return originalCatch.apply(target, [exception, host]);
          }

          captureException(exception);
          return originalCatch.apply(target, [exception, host]);
        };
      }
      return Reflect.get(target, prop, receiver);
    },
  });

  app.useGlobalFilters(wrappedFilter);
}

function addNestSpanAttributes(span) {
  const attributes = spanToJSON(span).data || {};

  // this is one of: app_creation, request_context, handler
  const type = attributes['nestjs.type'];

  // If this is already set, or we have no nest.js span, no need to process again...
  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] || !type) {
    return;
  }

  span.setAttributes({
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.nestjs',
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${type}.nestjs`,
  });
}

export { SentryNestInstrumentation, instrumentNest, isPatched, nestIntegration, setupNestErrorHandler };
//# sourceMappingURL=nest.js.map
