import type { InstrumentationConfig } from '@opentelemetry/instrumentation';
import { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';
interface MinimalNestJsExecutionContext {
    getType: () => string;
    switchToHttp: () => {
        getRequest: () => {
            route?: {
                path?: string;
            };
            method?: string;
        };
    };
}
interface NestJsErrorFilter {
    catch(exception: any, host: any): void;
}
interface MinimalNestJsApp {
    useGlobalFilters: (arg0: NestJsErrorFilter) => void;
    useGlobalInterceptors: (interceptor: {
        intercept: (context: MinimalNestJsExecutionContext, next: {
            handle: () => any;
        }) => any;
    }) => void;
}
/**
 * Represents an injectable target class in NestJS.
 */
export interface InjectableTarget {
    name: string;
    sentryPatched?: boolean;
    prototype: {
        use?: (req: unknown, res: unknown, next: () => void) => void;
    };
}
/**
 * Helper checking if a concrete target class is already patched.
 *
 * We already guard duplicate patching with isWrapped. However, isWrapped checks whether a file has been patched, whereas we use this check for concrete target classes.
 * This check might not be necessary, but better to play it safe.
 */
export declare function isPatched(target: InjectableTarget): boolean;
/**
 * Custom instrumentation for nestjs.
 *
 * This hooks into the @Injectable decorator, which is applied on class middleware, interceptors and guards.
 */
export declare class SentryNestInstrumentation extends InstrumentationBase {
    static readonly COMPONENT = "@nestjs/common";
    static readonly COMMON_ATTRIBUTES: {
        component: string;
    };
    constructor(config?: InstrumentationConfig);
    /**
     * Initializes the instrumentation by defining the modules to be patched.
     */
    init(): InstrumentationNodeModuleDefinition;
    /**
     * Wraps the @Injectable decorator.
     */
    private _getInjectableFileInstrumentation;
    /**
     * Creates a wrapper function for the @Injectable decorator.
     *
     * Wraps the use method to instrument nest class middleware.
     */
    private _createWrapInjectable;
}
export declare const instrumentNest: (() => void) & {
    id: string;
};
/**
 * Nest framework integration
 *
 * Capture tracing data for nest.
 */
export declare const nestIntegration: () => import("@sentry/types").Integration;
/**
 * Setup an error handler for Nest.
 */
export declare function setupNestErrorHandler(app: MinimalNestJsApp, baseFilter: NestJsErrorFilter): void;
export {};
//# sourceMappingURL=nest.d.ts.map